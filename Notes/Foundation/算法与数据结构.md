---
typora-root-url: pic
---

本章节部分题目来自：[牛客网top100](https://www.nowcoder.com/exam/oj?questionJobId=10&subTabName=online_coding_page)。

# 链表

## BM1：反转链表

BM2[链表内指定区间反转]和BM3[链表中的节点每k个一组翻转]都是BM1的扩展。

## BM4：合并两个已排序的链表

**双指针**：在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个）。两个指针或是同方向访问两个链表、或是同方向访问一个链表（**快慢指针**）、或是相反方向扫描（**对撞指针**），从而达到我们需要的目的。

## BM6：判断链表中是否有环

快慢指针。主要思想是利用环没有末尾NULL，后半部分一定是环，然后快慢双指针相遇就代表有环。

## BM7：找到链表中环的入口

step1：判断链表是否有环，并找到相遇的节点。

step2：慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素逐个元素开始遍历链表。

step3：再次相遇的地方就是环的入口。

## BM8：链表中倒数第k个节点

快慢指针，快指针和慢指针之间的间隔为k。

## BM10：找到两个链表的公共节点

使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。

让N1和N2一起遍历，当N1走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历；

当N2走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。

因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能**同时到达终点**。

```c++
ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) {
	if(!pHead1 || !pHead2)
		return nullptr;

	auto* n1 = pHead1;
	auto* n2 = pHead2;

	while(n1 != n2)
	{
		n1 = n1 ? n1->next : pHead2;
		n2 = n2 ? n2->next : pHead1;
	}
	return n1;
}
```

## BM12：单链表的排序

并归排序。

```c++
    ListNode* sortInList(ListNode* head) {
        if (!head || !head->next)
            return head;

        auto* left = head;
        auto* middle = head->next;
        auto* right = head->next->next;

        while (right && right->next) {
            left = left->next;
            middle = middle->next;
            right = right->next->next;
        }

        left->next = nullptr;
        return mergeSortedList(sortInList(head), sortInList(middle));
    }
```

## BM13：判断一个链表是否为回文结构

注意翻转链表会打断原链表的数据链接关系。

```c++
bool Algorithmn::isPalindrome(ListNode* head)
{
    if(!head)
        return false;

    if(!head->next)
        return true;

    std::vector<ListNode*> origin;
    auto* current = head;
    while(current)
    {
        origin.push_back(current);
        current = current->next;
    }
     
    auto* reversedList = reverse(head);
    for(size_t i = 0; i < origin.size(); i++)
    {
        if(origin[i]->val != reversedList->val)
        {
            return false;
        }
        reversedList = reversedList->next;
    }
    return true;
}
```


# 二分查找/排序

## 二分查找

```c++
int Algorithmn::search(std::vector<int>& nums, int target)
{
    if(nums.size() == 0)
        return -1;

    int left = 0;
    int right = nums.size() - 1;      
    if(nums[left] > target || nums[right] < target)
        return -1;

	int mid{ 0 };
    while(left <= right)
    {
        mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid;
        else if(nums[mid] > target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}
```

## 二维数组的查找

在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

思路：

a.首先从数组左下角搜索.
b.如果当前数字大于target,那么查找往上移一位,如果当前数字小于target,那么查找往右移一位。
c.查找到target,返回true; 如果越界，返回false;

# 树

## 红黑树

​	本小节参考自：[让你彻底搞懂红黑树](https://blog.csdn.net/cy973071263/article/details/122543826)、[红黑树详解](https://blog.csdn.net/u014454538/article/details/120120216)。

​	红黑树的应用：

- C++ STL中的map
- Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构。JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树
- 多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。

### 1 红黑树的引入

​	二叉搜索树容易退化成一条链，这时，查找的时间复杂度从$O(log_{2}N)$退化成$O(N)$。

​	因此引入对左右子树**高度差有限制的平衡二叉树(AVL)**，保证查找操作的最坏时间复杂度也为$O(log_{2}N)$。

​	有了AVL，为何还要引入红黑树：

- AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过**旋转操作**保持平衡；
- 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的**性能大打折扣；**
- 红黑树是通过**牺牲严格的平衡**，换取插入/删除时少量的旋转操作，整体性能优于AVL；
- 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决；
- 红黑树的红黑规则，保证最坏的情况下，也能在$O(log_{2}N)$时间内完成查找操作。

​	红黑树是一种**接近平衡的二叉树**，它通过满足红黑节点的5条性质，维持一种接近平衡的结构，从而提升性能。

### 2 红黑树的特性

​	有如下节点的概念：**parent**(父节点)、**sibling**(兄弟节点)、**uncle**(parent的兄弟节点)、**grand**(parent 的父节点)。

​	红黑树是一个**二叉搜索树**，每个节点增加了一个存储位记录节点的颜色：RED或BLACK。

​	通过任意一条从根到叶子节点路径上颜色的约束，**红黑树保证最长路径不超过最短路径的二倍**，因而近似平衡。它有如下特性：

1.节点是红色或黑色。

2.**根**是黑色。

3.**叶子节点**都是黑色，且为空节点(null)。

4.红色节点的**子节点**都是黑色，红色节点的**父节点**都是黑色：从根节点到叶子节点的路径上，**不能有2个连续的红色节点**。

5.任意节点到叶子节点的所有路径，都包含相同数目的黑色节点(相同的**黑色高度**)。

<img src="/math_red-black_tree.png" alt="math_red-black_tree" style="zoom:65%;" />

​	有如下示例，判断下图中的二叉树是否为红黑树：

<img src="/math_red-black_tree_test.png" alt="math_red-black_tree_test" style="zoom:67%;" />

<center>图片1</center>

<img src="/math_red-black_tree_test_2.png" alt="math_red-black_tree_test_2" style="zoom:60%;" />

<center>图片2 补全叶子节点</center>

​	上述图中1，节点25、74、78、86、90都包含其键值，因此不是叶子节点。图2中，**把叶子节点补全后**，发现路线1和路线2的黑色节点数不同，不满足约束条件5，因此其不是红黑树。一般情况下，叶子节点**不在图中标识**。

### 3 红黑树的等价变换

<img src="/math_red-black_tree_transformation.png" alt="math_red-black_tree_transformation" style="zoom:67%;" />

​	上图中红黑树，将所有红色节点移动到和他们的父节点同一高度上，会形成如下结构：

<img src="/math_red-black_tree_transformation_2.png" alt="math_red-black_tree_transformation" style="zoom:67%;" />

​	这是一个四阶B树(一个节点最多存放三个数据)，用下图表示更加清晰：

<img src="/math_B_4_tree.png" alt="math_B_4_tree" style="zoom:67%;" />

### 4 红黑树的操作

​	红黑树是一种**自平衡**的二叉查找树。其包含查找、插入、删除等操作。

#### 1) 查找操作

​	红黑树的查找和二叉搜索树一致，二叉搜索树特点如下：

- 若它的左子树不为空，则左子树上所有节点的值都小于根节点的值；
- 若它的右子树不为空，则右子树上所有节点的值都大于根节点的值；
- 它的左右子树也分别为二叉搜索树。

​	二叉搜索树的查找逻辑如下：

- 从根开始比较，查找，比根大则往右边走查找，比根小则往左边走查找。
- **最多查找高度次**，走到空，还没找到，则这个值不存在。

​	综上，搜索二叉树搜索效率，最优情况下是$O(logN)$，最差情况是$O(N)$。

#### 2) 旋转操作

​	旋转操作在插入、删除操作中都会被使用到，旋转分为左旋和右旋。

​	**左旋**：将节点旋转为其右孩子的左孩子，**右旋**：将节点旋转为其左孩子的右孩子。

​	下述以右旋为例：① 将节点 M 的左孩子引用指向节点 E 的右孩子；② 将节点 E 的右孩子引用指向节点 M，完成旋转。如下图所示：

<img src="/math_red-black_tree_right_rotate.png" alt="math_red-black_tree_right_rotate" style="zoom:80%;" />

​	左旋操作与此类似，只是右旋转的逆操作。

#### 3) 插入操作

​	红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。

##### 3.1) 插入操作, 新节点应该为红色

​	如果是**添加根节点**，则将节点设定为**黑色**。

​	如果是子节点，则将节点设定为**红色**，分析如下：

​	如果插入的子节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦(参考红黑树的删除操作)。

​	如果插入的子节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转调整即可，比插入黑色节点更简单。

​	所以插入子节点设置为红色，可以保证满足性质 1、2、3、5 ，只有性质4不一定满足，需要进行相关调整。

##### 3.2) 插入操作的所有情况

​	我们使用红黑树的等价形式来讨论红黑树的插入，如下图：

## 二叉树

### 前序遍历

```c++
// 前序遍历
std::vector<int> preorderTraversal(TreeNode* root)
{
    std::vector<int> result;
    std::stack<TreeNode*> stack;
    if(root)
        stack.push(root);
    while(!stack.empty())
    {
        auto* node = stack.top();
        stack.pop();

        result.push_back(node->val);

        if(node->right)
            stack.push(node->right);

        if(node->left)
            stack.push(node->left);
    }
    return result;
}
```

### 中序遍历

```c++
// 中序遍历
std::vector<int> inorderTraversal(TreeNode* root)
{
    std::vector<int> result;
    std::stack<TreeNode*> stack;

    while(root || !stack.empty())
    {
        // 深度优先找到左子节点
        while(root)
        {
            stack.push(root);
            root = root->left;
        }

        auto* node = stack.top();
        stack.pop();
        result.push_back(node->val);

        root = node->right;
    }
    return result;
}
```

### 后序遍历

```c++
// 后序遍历
std::vector<int> postorderTraversal(TreeNode* root)
{
    std::vector<int> result;
    std::stack<TreeNode*> stack;
    // 标记被访问的节点
    TreeNode* pre{ nullptr };
    while(root || !stack.empty())
    {
        while(root)
        {
            stack.push(root);
            root = root->left;
        }

        auto* node = stack.top();
        stack.pop();

        if(!node->right || pre == node->right)
        {
            // 访问节点
            result.push_back(node->val);
            pre = node;
        }
        else
        {
            stack.push(node);
            root = node->right;
        }
    }
    return result;
}
```

### 广度优先遍历，使用队列

```c++
std::vector<std::vector<int>> result;
std::queue<TreeNode*> queue;
if(root)
    queue.push(root);

while(!queue.empty())
{
    // 每次while循环, 遍历当前层数所有的节点
    auto n = queue.size();
    std::vector<int> row;
    row.reserve(n);
    for(size_t i = 0; i < n; i++)
    {
        auto* node = queue.front();
        queue.pop();
        row.push_back(node->val);

        if(node->left)
            queue.push(node->left);

        if(node->right)
            queue.push(node->right);
    }
    result.push_back(row);
}
return result;
```

### BM32 合并二叉树

使用广度优先遍历，使三个队列：合并队列，树1队列、树2队列的内部成员数量保持一致：

```c++
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2)
{
    if(!t1 && !t2)
        return nullptr;

    if(t1 && !t2)
        return t1;

    if(!t1 && t2)
        return t2;

    TreeNode* head = new TreeNode(0);
    std::queue<TreeNode*> queue1;
    std::queue<TreeNode*> queue2;
    std::queue<TreeNode*> merge;
    queue1.push(t1);
    queue2.push(t2);
    merge.push(head);

    while(!queue1.empty() && !queue2.empty())
    {
        auto* node1 = queue1.front();
        auto* node2 = queue2.front();
        auto* current = merge.front();
        queue1.pop(); queue2.pop(); merge.pop();

        current->val = node1->val + node2->val;

        if(node1->left && node2->left)
        {
            current->left = new TreeNode(0);
            queue1.push(node1->left);
            queue2.push(node2->left);
            merge.push(current->left);
        }
        else if(node1->left)
            current->left = node1->left;
        else
            current->left = node2->left;

        if(node1->right && node2->right)
        {
            current->right = new TreeNode(0);
            queue1.push(node1->right);
            queue2.push(node2->right);
            merge.push(current->right);
        }
        else if(node1->right)
            current->right = node1->right;
        else
            current->right = node2->right;
    }
    return head;
}
```

### BM34 判断是不是二叉搜索树

step1.使用后序遍历

step2.在节点上判断，pre是左子节点还是右子节点

step3.判断条件：(左子节点 < 当前节点) && (右子节点 > 当前节点) && (左子树的最大值 < 当前节点) && (右子树的最小值 > 当前节点)；

# 堆/栈/队列

## 大根堆

### 1 原理

大根堆是一种特殊的**完全二叉树**，其核心特性是：**每个节点的值都大于或等于其子节点的值**。

大根堆的堆顶元素始终是**最大值**。

大根堆通常使用**数组**来存储，对于位置`i`的节点，有：

- **父节点**位置为`(i-1)/2`
- **左子节点**位置为`2*i+1`
- **右子节点**位置为`2*i+2`

### 2 STL实现

C++标准模板库提供了`priority_queue`容器，默认实现的就是大根堆：

```c++
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // 声明一个大根堆
    priority_queue<int> maxHeap;
    // 插入元素
    maxHeap.push(5);
    maxHeap.push(2);
    maxHeap.push(7);
    maxHeap.push(1);
    maxHeap.push(9);
    // 访问堆顶元素（最大值）
    cout << "堆顶元素: " << maxHeap.top() << endl; // 输出9
    // 弹出堆顶元素
    maxHeap.pop();
    cout << "弹出后堆顶元素: " << maxHeap.top() << endl; // 输出7
    // 遍历堆（弹出所有元素）
    cout << "堆中所有元素: ";
    while (!maxHeap.empty()) {
        cout << maxHeap.top() << " ";
        maxHeap.pop();
    }
    // 输出: 7 5 2 1
    return 0;
}
```

### 3 实现一个大根堆

```c++
class MaxHeap 
{
public:
    // 插入元素
    void push(int value) {
        // 将新元素添加到堆的末尾
        heap.push_back(value);
        // 执行上浮调整
        heapifyUp(heap.size() - 1);
    }
    
    // 删除堆顶元素
    void pop() {
        if (heap.empty()) return;
        
        // 用堆的最后一个元素替换堆顶元素
        heap[0] = heap.back();
        // 删除最后一个元素
        heap.pop_back();
        // 执行下沉调整
        heapifyDown(0);
    }
    
    // 获取堆顶元素
    int top() {
        if (!heap.empty()) 
            return heap[0];
        
        throw out_of_range("堆为空");
    }
    
    // 判断堆是否为空
    bool empty() { return heap.empty(); }
    
    // 获取堆大小
    int size() { return heap.size(); }
private:
    // 上浮操作（用于插入）
    void heapifyUp(int i) {
        // 比较新元素与其父节点的值，如果新元素值较大，则与父节点交换位置
        // 重复此过程，直到新元素到达合适的位置
        while (i > 0 && heap[i] > heap[parent(i)]) {
            swap(heap[i], heap[parent(i)]);
            i = parent(i);
        }
    }
    
    // 下沉操作（用于删除和建堆）
    void heapifyDown(int i) {
        int maxIndex = i;
        int left = leftChild(i);
        int right = rightChild(i);
        int size = heap.size();
        
        // 找出当前节点、左子节点、右子节点中的最大值
        if (left < size && heap[left] > heap[maxIndex]) {
            maxIndex = left;
        }
        if (right < size && heap[right] > heap[maxIndex]) {
            maxIndex = right;
        }
        
        // 如果最大值不是当前节点，交换并继续下沉
        if (i != maxIndex) {
            swap(heap[i], heap[maxIndex]);
            heapifyDown(maxIndex);
        }
    }
    
    // 获取节点关系
    int parent(int i) { return (i-1)/2; }
    int leftChild(int i) { return 2*i+1; }
    int rightChild(int i) { return 2*i+2; }
    
 private:
    vector<int> heap;
}
```

## 小根堆

### 1 原理

原理同大根堆，区别：**每个节点的值都小于或等于其子节点的值**。

### 2 STL实现

```c++
// 使用std::greater<int>实现小根堆
priority_queue<int, vector<int>, greater<int>> minHeap;
```

### 3 实现一个小根堆

原理同大根堆，只是上浮操作和下沉操作的比较条件不同。

```c++
class MinHeap {
	// 省略重复代码
    // ......
    // ......
    
    // 上浮操作, 用于插入元素后调整堆
    void heapifyUp(int i) {
        while (i > 0 && heap[i]< heap[parent(i)]) {
            swap(heap[i], heap[parent(i)]);
            i = parent(i);
        }
    }
    
    // 下沉操作, 用于删除堆顶元素后调整堆
    void heapifyDown(int i) {
        int minIndex = i;
        int left = leftChild(i);
        int right = rightChild(i);
        int size = heap.size();
        
        // 找出当前节点、左子节点、右子节点中的最小值
        if (left < size && heap[left] < heap[minIndex]) {
            minIndex = left;
        }
        
        if (right < size && heap[right] < heap[minIndex]) {
            minIndex = right;
        }
        
        // 如果最小值不是当前节点，交换并继续下沉
        if (i != minIndex) {
            swap(heap[i], heap[minIndex]);
            heapifyDown(minIndex);
        }
    }
}
```

## **BM43** **包含min函数的栈**

栈的各个操作的时间复杂度是O(1)，空间复杂度是O(n) ，使用双栈法：

```c++
class SStack
{
public:
    void push(int value)
    {
        //两个栈内的元素始终保持同步
        s1.push(value); 
        if(s2.empty() || value < s2.top())
            s2.push(value);
        else
            s2.push(s2.top());
    }

    void pop()
    {
        s1.pop();
        s2.pop();
    }

    int top() { return s1.top(); }

    int min() { return s2.top(); }

private:
    std::stack<int> s1;
    std::stack<int> s2;
};
```

## BM48 数据流中的中位数

可以使用**插入排序**，然后再获取中位数。

但是插入排序**每次要遍历整个已有的数组**，很浪费时间。因此考虑性能更优的方案。

看看中位数的特征：它是数组中间一个数字或者两个数字的均值。它是数组**较小的一半元素中最大的一个**，同时也是数**组较大的一半元素中最小的一个**。

只要每次维护最小的一半元素和最大的一半元素，并能快速得到它们的最大值和最小值，从而获取中位数。

```c++
class Median
{
public:
    void Insert(int num)
    {
        if(m_MinHeap.empty())
        {
            m_MinHeap.push(num);
            return;
        }
        
        // 插入新值
        m_MinHeap.push(num);
        // 将较小的部分, 放到大根堆中
        m_MaxHeap.push(m_MinHeap.top());
        m_MinHeap.pop();

        // 维持两个堆的数量, 使m_MinHeap.size() >= m_MaxHeap.size()
        while(!m_MinHeap.empty() && m_MinHeap.size() < m_MaxHeap.size())
        {            
            m_MinHeap.push(m_MaxHeap.top());
            m_MaxHeap.pop();
        }
    }

    double GetMedian()
    {
        if(m_MinHeap.size() == m_MaxHeap.size())//偶数
            return (m_MinHeap.top() + m_MaxHeap.top()) * 0.5;
        else//奇数
            return m_MinHeap.top();
    }
    
private:
    // 大根堆: 存储数据里较小的一半
    std::priority_queue<int> m_MaxHeap;
    // 小根堆: 存储数据里较大的一半
    std::priority_queue<int, std::vector<int>, std::greater<int>> m_MinHeap;  
};
```

## BM45 滑动窗口的最大值

若一个数字A进入窗口后，其比窗口内其他数字都大，那么这个数字之前的数字都没用了，因为它们必定会比A早离开窗口，且在A离开之前都争不过A。

所以A在进入时依次从尾部排除掉之前的小值再进入，而每次窗口移动要弹出窗口最前面值，即队首也需要弹出。

综上选择**双向队列**。

```c++
std::vector<int> maxInWindows(std::vector<int>& num, int size)
{
    std::deque<int> deque;
    std::vector<int> result;
    if(num.size() < size || size == 0)
        return result;

    for(size_t i = 0; i < size; ++i)
    {
        // 队列中弹出比num[i]小的值, 使最大值始终在队列的头部
        while(!deque.empty() && num[deque.back()] < num[i])
            deque.pop_back();
        deque.push_back(i);
    }
    result.push_back(num[deque.front()]);

    for(size_t i = size; i < num.size(); ++i)
    {
        // 窗口移动后, 弹出窗口左边的值
        while(!deque.empty() && deque.front() < (i - size + 1))
            deque.pop_front();

        while(!deque.empty() && num[deque.back()] < num[i])
            deque.pop_back();

        deque.push_back(i);
        result.push_back(num[deque.front()]);
    }
    return result;
}
```

# 递归/回溯

## BM58 字符串的排列

<img src="/pic_BM58_str_permutation.png" alt="pic_BM58_str_permutation" style="zoom:100%;" />

```c++
void recursiveStr(std::string& str, int index, std::vector<std::string>& res)
{
    if(index == str.size() - 1)
    {
        res.push_back(str);
        return;
    }

    for(size_t i = index; i < str.size(); ++i)
    {        
        // 去重
        if(i != index && str[i] == str[index])
            continue;
        // 去重
        if(i != index && i >= 1 && str[i] == str[i - 1])
            continue;
        swapStr(str, index, i);
        recursiveStr(str, index + 1, res);
        swapStr(str, index, i);
    }
}

std::vector<std::string> Permutation(std::string str)
{
    std::vector<std::string> res;
    if(str.empty())
        res.push_back("");
    else
        recursiveStr(str, 0, res);
    return res;
}
```

## BM60 括号生成

```c++
class Solution {
public:
    void recursion(int left, int right, string temp, vector<string> &res, int n){
        //左右括号都用完了，就加入结果
        if(left == n && right == n){ 
            res.push_back(temp);
            return;
        }
        //使用一次左括号
        if(left < n) 
            recursion(left + 1, right, temp + "(", res, n);
        //使用右括号个数必须少于左括号
        if(right < n && left > right) 
            recursion(left, right + 1, temp + ")", res, n);
    }
    
    vector<string> generateParenthesis(int n) {
        //记录结果
        vector<string> res; 
        //记录每次组装的字符串
        string temp; 
        //递归
        recursion(0, 0, temp, res, n); 
        return res;
    }
};
```

# 双指针

## BM89 合并区间

```c++
static bool cmpInterval(const Interval& lhs, const Interval& rhs) {
    return lhs.start < rhs.start;
}

vector<Interval> merge(vector<Interval>& intervals) {
    std::vector<Interval> res;
    if (intervals.empty())
        return r
    std::sort(intervals.begin(), intervals.end(), cmpInterval);
    res.push_back(intervals[0
    for (size_t i = 1; i < intervals.size(); i++) {
        if (intervals[i].start <= res.back().end) {
            res.back().end = std::max(intervals[i].end, res.back().end);
        } else
            res.push_back(intervals[i]);
    }
    return res;
}
```

## BM93 盛水最多的容器

这道题利用了水桶的短板原理，**较短的一边控制最大水量**，因此直接用较短边长乘底部两边距离就可以得到当前情况下的容积。但是要怎么找最大值呢？

可以利用**贪心思想**：我们都知道容积与最短边长和底边长有关，与长的底边一定以首尾为边，但是首尾不一定够高，中间可能会出现更高但是底边更短的情况，因此我们可以使用对撞双指针向中间靠，这样底边长会缩短，因此还想要有更大容积只能是增加最短边长，此时我们每次指针移动就移动较短的一边，因为贪心思想下较长的一边比较短的一边更可能出现更大容积。

```c++
int maxArea(std::vector<int>& height)
{
    if(height.size() < 2)
        return 0;

    int res = 0;
    int l = 0;
    int r = height.size() - 1;
    while(l < r)
    {
        int area = (r - l) * std::min(height[l], height[r]);
        res = std::max(res, area);
        if(height[l] < height[r])
            ++l;
        else
            --r;
    }
    return res;
}
```

# 动态规划

## BM64 最小花费爬楼梯

```c++
int Algorithmn::minCostClimbingStairs(std::vector<int>& cost)
{
    //dp[i]表示爬到第i阶楼梯需要的最小花费
    std::vector<int> dp(cost.size() + 1, 0);
    for (int i = 2; i <= cost.size(); i++)
        //每次选取最小的方案
        dp[i] = std::min(dp[i - 1] + cost[i - 1], 
                         dp[i - 2] + cost[i - 2]);
    return dp[cost.size()];
}
```

