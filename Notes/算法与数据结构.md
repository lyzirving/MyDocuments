# 二叉树

## 1 广度优先搜索

​	广度优先搜索：从root开始，从上至下，从左到右依次遍历。

​	利用队列**后进先出**的特性，通过双队列的形式实现广度优先搜索，双队列是在单队列基础上的优化。

```c++
// Breadth-first search
void Node::BFS(Node *root)
{
	if (!root)
		return;

	std::queue<Node *> queue1, queue2;
	queue1.push(root);

	while (!queue1.empty())
	{
		auto *node = queue1.back();
		if (node->left)
			queue2.push(node->left);

		if (node->right)
			queue2.push(node->right);

		queue1.pop();		
		if (queue1.empty())// finish current floor
		{			
			// do something ......
			queue1.swap(queue2);//start to iterate the next floor if any			
		}
	}
}
```

# 红黑树详解

​	本小节参考自：[让你彻底搞懂红黑树](https://blog.csdn.net/cy973071263/article/details/122543826)、[红黑树详解](https://blog.csdn.net/u014454538/article/details/120120216)。

​	红黑树的应用：

- C++ STL中的map
- Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构。JDK 1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树
- 多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。

## 1 红黑树的引入

​	二叉搜索树容易退化成一条链，这时，查找的时间复杂度从$O(log_{2}N)$退化成$O(N)$。

​	因此引入对左右子树**高度差有限制的平衡二叉树(AVL)**，保证查找操作的最坏时间复杂度也为$O(log_{2}N)$。

​	有了AVL，为何还要引入红黑树：

- AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过**旋转操作**保持平衡；
- 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的**性能大打折扣；**
- 红黑树是通过**牺牲严格的平衡**，换取插入/删除时少量的旋转操作，整体性能优于AVL；
- 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决；
- 红黑树的红黑规则，保证最坏的情况下，也能在$O(log_{2}N)$时间内完成查找操作。

​	红黑树是一种**接近平衡的二叉树**，它通过满足红黑节点的5条性质，维持一种接近平衡的结构，从而提升性能。

## 2 红黑树的特性

​	有如下节点的概念：**parent**(父节点)、**sibling**(兄弟节点)、**uncle**(parent的兄弟节点)、**grand**(parent 的父节点)。

​	红黑树是一个**二叉搜索树**，每个节点增加了一个存储位记录节点的颜色：RED或BLACK。

​	通过任意一条从根到叶子节点路径上颜色的约束，**红黑树保证最长路径不超过最短路径的二倍**，因而近似平衡。它有如下特性：

1.节点是红色或黑色。

2.**根**是黑色。

3.**叶子节点**都是黑色，且为空节点(null)。

4.红色节点的**子节点**都是黑色，红色节点的**父节点**都是黑色：从根节点到叶子节点的路径上，**不能有2个连续的红色节点**。

5.任意节点到叶子节点的所有路径，都包含相同数目的黑色节点(相同的**黑色高度**)。

<img src=".\pic\math_red-black_tree.png" alt="math_red-black_tree" style="zoom:65%;" />

​	有如下示例，判断下图中的二叉树是否为红黑树：

<img src=".\pic\math_red-black_tree_test.png" alt="math_red-black_tree_test" style="zoom:67%;" />

<center>图片1</center>

<img src=".\pic\math_red-black_tree_test_2.png" alt="math_red-black_tree_test_2" style="zoom:60%;" />

<center>图片2 补全叶子节点</center>

​	上述图中1，节点25、74、78、86、90都包含其键值，因此不是叶子节点。图2中，**把叶子节点补全后**，发现路线1和路线2的黑色节点数不同，不满足约束条件5，因此其不是红黑树。一般情况下，叶子节点**不在图中标识**。

## 3 红黑树的等价变换

<img src=".\pic\math_red-black_tree_transformation.png" alt="math_red-black_tree_transformation" style="zoom:67%;" />

​	上图中红黑树，将所有红色节点移动到和他们的父节点同一高度上，会形成如下结构：

<img src=".\pic\math_red-black_tree_transformation_2.png" alt="math_red-black_tree_transformation" style="zoom:67%;" />

​	这是一个四阶B树(一个节点最多存放三个数据)，用下图表示更加清晰：

<img src=".\pic\math_B_4_tree.png" alt="math_B_4_tree" style="zoom:67%;" />

## 4 红黑树的操作

​	红黑树是一种**自平衡**的二叉查找树。其包含查找、插入、删除等操作。

### 1) 查找操作

​	红黑树的查找和二叉搜索树一致，二叉搜索树特点如下：

- 若它的左子树不为空，则左子树上所有节点的值都小于根节点的值；
- 若它的右子树不为空，则右子树上所有节点的值都大于根节点的值；
- 它的左右子树也分别为二叉搜索树。

​	二叉搜索树的查找逻辑如下：

- 从根开始比较，查找，比根大则往右边走查找，比根小则往左边走查找。
- **最多查找高度次**，走到空，还没找到，则这个值不存在。

​	综上，搜索二叉树搜索效率，最优情况下是$O(logN)$，最差情况是$O(N)$。

### 2) 旋转操作

​	旋转操作在插入、删除操作中都会被使用到，旋转分为左旋和右旋。

​	**左旋**：将节点旋转为其右孩子的左孩子，**右旋**：将节点旋转为其左孩子的右孩子。

​	下述以右旋为例：① 将节点 M 的左孩子引用指向节点 E 的右孩子；② 将节点 E 的右孩子引用指向节点 M，完成旋转。如下图所示：

<img src=".\pic\math_red-black_tree_right_rotate.png" alt="math_red-black_tree_right_rotate" style="zoom:80%;" />

​	左旋操作与此类似，只是右旋转的逆操作。

### 3) 插入操作

​	红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。

#### 3.1) 插入操作, 新节点应该为红色

​	如果是**添加根节点**，则将节点设定为**黑色**。

​	如果是子节点，则将节点设定为**红色**，分析如下：

​	如果插入的子节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦(参考红黑树的删除操作)。

​	如果插入的子节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转调整即可，比插入黑色节点更简单。

​	所以插入子节点设置为红色，可以保证满足性质 1、2、3、5 ，只有性质4不一定满足，需要进行相关调整。

#### 3.2) 插入操作的所有情况

​	我们使用红黑树的等价形式来讨论红黑树的插入，如下图：





​	











