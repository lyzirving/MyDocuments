# CPU结构和工作原理

<img src=".\pic\computer_foundation.png" alt="computer_foundation" style="zoom:70%;" />

## 1 进程和线程

​	程序未运行时，存储在计算机的**硬盘**上。

​	当双击启动程序时，它被**load**到内存中，操作系统为它分配一个**进程**。

​	进程是**资源分配**的**基本单位**，它是**静态**的，只分配了资源，没有运行。 

​	操作系统找到**程序入口函数(main)**，找到的第一条指令，发送给CPU(若需要数据，也发送给CPU)。如此循环往复，直到执行完所有指令，程序结束。

​	执行main函数的地方就是程序的**主线程**，线程是**运行的基本单位**，会占用CPU的时间片，是**动态**的概念。

## 2 CPU

​	CPU的工作：① 读取程序的指令和数据；② 执行运算；③ 写回结果。

​	**程序计数器**(PC，program counter)：存储程序指令。

​	**寄存器**(Registers)：存储临时数据。

​	**ALU**：执行运算。

​	**CPU缓存**：提高存取数据的效率。

<img src=".\pic\computer_foundation_cpu.png" alt="computer_foundation_cpu" style="zoom:50%;" />

### 1) CPU线程切换

​	一颗CPU，在同一个时间点上，只能有一个线程运行。

​	① 当线程切换时，CPU把PC中正在执行的指令和寄存器中的数据取出，存储起来。

​	② 让其他线程的指令占用PC和寄存器。

​	③ 切换回线程时，将存储的指令和数据取出，分别放回PC和寄存器中，让线程恢复到上次暂停的地方，继续执行。

​	**线程切换是有消耗的**，因此线程数量并不是越多越好。

### 2) CPU的缓存

#### 2.1) CPU和内存速度

​	CPU访问**本地寄存器**的速度和访问**内存**的速度比约为**100:1**，即访问寄存器消耗1ns，那么访问内存中的数据大约为100ns。

​	因此，若CPU从内存中取数据，会消耗CPU时钟周期，使CPU等待。

#### 2.2) 缓存结构

​	在CPU和内存之间加入中间层：若寄存器中找不到数据，则优先在缓存中取，最后再到内存中取。

​	若**缓存层级多**，则查找命中高，但同时修改数据的代价也变高，因为要把数据同步到多级缓存中。

​	若**缓存层级少**，则修改代价低，但缓存命中也不高，可能需要频繁返回内存读取数据。

​	目前最流行的是**三级缓存**，这是权衡和妥协的结果。

##### 2.2.1) 三级缓存结构

<img src=".\pic\pc_three_level_cache.png" alt="pc_three_level_cache" style="zoom:70%;" />

​	上图中有2颗CPU，每个CPU有2个核，**每个核**可以单独跑一个线程。

- 缓存介绍

​	**L1**：CPU内部单核中最直接的缓存。**L2**：CPU内部单核的第二级缓存。**L3**：CPU内部多核共享的缓存，第三级缓存。**多个CPU共享主内存**。

- 存取数据

​	当寄存器需要使用数据时，依次从**L1、L2、L3**中去寻找。若都不找到，从内存中获取。

​	从内存中得到的数据，会依次存入**L3、L2、L1**，最后放至寄存器中使用。

##### 2.2.1) 缓存行

​	CPU缓存获取数据时，一次获取**一整块**的内存数据，放入缓存。那么这一块数据，通常称为**缓存行(cache line)**。

​	缓存行是CPU缓存中可分配、操作的**最小存储单元**。

​	缓存行的大小需要权衡和妥协：若缓存行大，命中率高，但更新效率低；若缓存行小，更新效率高，但命中率低。

​	缓存行的大小与CPU架构有关，通常有32字节、64字节、128字节不等。目前64位架构下，**64字节**最为常用。

##### 2.2.2) 缓存一致性

<img src=".\pic\pc_cache_consistency.png" alt="pc_cache_consistency" style="zoom:50%;" />

- 缓存一致性

​	CPU1读取了数据x，CPU2读取数据y。由于x、y是连续的，所以会被CPU缓存加载到同一个缓存行当中。

​	若CPU1修改了x，需要将x的修改通知到CPU2；若CPU2修改了y，需要把y的修改通知到CPU1，否则会出现问题。

​	上述即缓存一致性问题，由于缓存行的存在，部分**连续的数据可能被不同缓存行共享**。缓存一致性是因为共享引起的。

​	不同CPU有不同的缓存一致性协议和实现，缓存一致性不存在标准。

- 缓存填充

​	**维护缓存一致性要消耗一定的系统时间**，因此，出现了一些软件上的优化手段，如**缓存填充**。

​	让关键的、多线程明确访问的数据，放在单独的缓存行里，避免缓存一致性维护开销。

​	例子：

```c++
struct Filed
{
	int64_t p0, p1, p2, p3, p4, p5, p6;
	int64_5 X;
	int64_t p7, p8, p9, p10, p11, p12, p13;
}
```

​	Filed的val变量必然是多线程访问的。采用了56+8+56的结构，把val隔离出来。

​	CPU缓存读取val时，它肯定在**单独的缓存行**上。

<img src=".\pic\pc_cache_line_filling.png" alt="pc_cache_line_filling" style="zoom:70%;" />

​	X的前、后方都填充了56byte的数据，**保证X不会和其他数据填充至同一个缓存行中，产生共享**，避免了缓存一致性的开销。

### 3) 线程的有序性

# 什么是纤程？什么是协程？



# 逻辑地址，物理地址和虚拟地址

