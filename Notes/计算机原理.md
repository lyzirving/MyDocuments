# CPU结构和工作原理

<img src=".\pic\computer_foundation.png" alt="computer_foundation" style="zoom:70%;" />

## 1 进程和线程

​	程序未运行时，存储在计算机的**硬盘**上。

​	当双击启动程序时，它被**load**到内存中，操作系统为它分配一个**进程**。

​	进程是**资源分配**的**基本单位**，它是**静态**的，只分配了资源，没有运行。 

​	操作系统找到**程序入口函数(main)**，找到的第一条指令，发送给CPU(若需要数据，也发送给CPU)。如此循环往复，直到执行完所有指令，程序结束。

​	执行main函数的地方就是程序的**主线程**，线程是**运行的基本单位**，会占用CPU的时间片，是**动态**的概念。

## 2 CPU

​	CPU的工作：① 读取程序的指令和数据；② 执行运算；③ 写回结果。

​	**程序计数器**(PC，program counter)：存储程序指令。

​	**寄存器**(Registers)：存储临时数据。

​	**ALU**：执行运算。

​	**CPU缓存**：提高存取数据的效率。

<img src=".\pic\computer_foundation_cpu.png" alt="computer_foundation_cpu" style="zoom:50%;" />

### 1) CPU线程切换

​	一颗CPU，在同一个时间点上，只能有一个线程运行。

​	① 当线程切换时，CPU把PC中正在执行的指令和寄存器中的数据取出，存储起来。

​	② 让其他线程的指令占用PC和寄存器。

​	③ 切换回线程时，将存储的指令和数据取出，分别放回PC和寄存器中，让线程恢复到上次暂停的地方，继续执行。

​	**线程切换是有消耗的**，因此线程数量并不是越多越好。

### 2) CPU的缓存

#### 2.1) CPU和内存速度

​	CPU访问**本地寄存器**的速度和访问**内存**的速度比约为**100:1**，即访问寄存器消耗1ns，那么访问内存中的数据大约为100ns。

​	因此，若CPU从内存中取数据，会消耗CPU时钟周期，使CPU等待。

#### 2.2) 缓存结构

​	在CPU和内存之间加入中间层：若寄存器中找不到数据，则优先在缓存中取，最后再到内存中取。

​	若**缓存层级多**，则查找命中高，但同时修改数据的代价也变高，因为要把数据同步到多级缓存中。

​	若**缓存层级少**，则修改代价低，但缓存命中也不高，可能需要频繁返回内存读取数据。

​	目前最流行的是**三级缓存**，这是权衡和妥协的结果。

##### 2.2.1) 三级缓存结构

<img src=".\pic\pc_three_level_cache.png" alt="pc_three_level_cache" style="zoom:70%;" />

​	上图中有2颗CPU，每个CPU有2个核，**每个核**可以单独跑一个线程。

- 缓存介绍

​	**L1**：CPU内部单核中最直接的缓存。**L2**：CPU内部单核的第二级缓存。**L3**：CPU内部多核共享的缓存，第三级缓存。**多个CPU共享主内存**。

- 存取数据

​	当寄存器需要使用数据时，依次从**L1、L2、L3**中去寻找。若都不找到，从内存中获取。

​	从内存中得到的数据，会依次存入**L3、L2、L1**，最后放至寄存器中使用。

##### 2.2.1) 缓存行

​	CPU缓存获取数据时，一次获取**一整块**的内存数据，放入缓存。那么这一块数据，通常称为**缓存行(cache line)**。

​	缓存行是CPU缓存中可分配、操作的**最小存储单元**。

​	缓存行的大小需要权衡和妥协：若缓存行大，命中率高，但更新效率低；若缓存行小，更新效率高，但命中率低。

​	缓存行的大小与CPU架构有关，通常有32字节、64字节、128字节不等。目前64位架构下，**64字节**最为常用。

##### 2.2.2) 缓存一致性

<img src=".\pic\pc_cache_consistency.png" alt="pc_cache_consistency" style="zoom:50%;" />

- 缓存一致性

​	CPU1读取了数据x，CPU2读取数据y。由于x、y是连续的，所以会被CPU缓存加载到同一个缓存行当中。

​	若CPU1修改了x，需要将x的修改通知到CPU2；若CPU2修改了y，需要把y的修改通知到CPU1，否则会出现问题。

​	上述即缓存一致性问题，由于缓存行的存在，部分**连续的数据可能被不同缓存行共享**。缓存一致性是因为共享引起的。

​	不同CPU有不同的缓存一致性协议和实现，缓存一致性不存在标准。

- 缓存填充

​	**维护缓存一致性要消耗一定的系统时间**，因此，出现了一些软件上的优化手段，如**缓存填充**。

​	让关键的、多线程明确访问的数据，放在单独的缓存行里，避免缓存一致性维护开销。

​	例子：

```c++
struct Filed
{
	int64_t p0, p1, p2, p3, p4, p5, p6;
	int64_5 X;
	int64_t p7, p8, p9, p10, p11, p12, p13;
}
```

​	Filed的val变量必然是多线程访问的。采用了56+8+56的结构，把val隔离出来。

​	CPU缓存读取val时，它肯定在**单独的缓存行**上。

<img src=".\pic\pc_cache_line_filling.png" alt="pc_cache_line_filling" style="zoom:70%;" />

​	X的前、后方都填充了56byte的数据，**保证X不会和其他数据填充至同一个缓存行中，产生共享**，避免了缓存一致性的开销。

### 3) 线程的有序性

​	锁能保证代码的原子性、可见性，但不能保证有序性(**指令重拍序**)。

​	经典的有序性问题就是单例的Double Check Lock，有如下java代码：

```java
if(INSTANCE == null) {
	synchronized(Mgr.class) {
		if(INSTANCE == null) { INSTANCE = new Mgr(); }
	}
}
```

​	对象初始化过程如下：

<img src=".\pic\pc_cmd_order.png" alt="pc_cmd_order" style="zoom: 60%;" />

​	因为有**指令重排序**，指令4和指令7可能变换顺序。

​	若正在发生上述指令重排，第二个线程调用了get()，就可能得到未初始化的INSTANCE，因为第一个判空条件没有上锁，不会保证原子性。

# 线程优先级和线程调度策略

​	本小节参考自：[C/C++调整线程优先级](https://blog.csdn.net/weixin_43273308/article/details/130119620)。	

​	线程优先级特征：

- 线程优先级指操作系统为每个线程分配的一定的**执行权重**，通过调整线程的优先级，可以决定哪些线程先被执行，哪些线程后被执行。
- 线程优先级影响着线程竞争CPU的时间片大小，优先级越高的线程获得的**时间片就越大**。
- 当多个线程竞争CPU时间片时，操作系统会根据线程优先级高低进行调度。
- Linux系统中，线程优先级是一个整数，范围是1~99。**默认**情况下，所有线程的优先级是**相同的**(中等优先级)。

## 1 Linux线程属性(含优先级)

- 创建线程属性参数

```c++
pthread_attr_init(pthread_attr_t *attr) //创建线程属性参数, 属性值用于在pthread_create中构建线程
```

​	其中线程参数的结构体如下：

```c++
typedef struct
{
       int                       detachstate;   // 线程的分离状态
       int                       schedpolicy;   // 线程调度策略
       structsched_param         schedparam;    // 线程的调度参数
       int                       inheritsched;  // 线程的继承性
       int                       scope;         // 线程的作用域
       size_t                    guardsize;     // 线程栈末尾的警戒缓冲区大小
       int                       stackaddr_set; // 线程的栈设置
       void*                     stackaddr;     // 线程栈的位置
       size_t                    stacksize;     // 线程栈的大小
} pthread_attr_t;
```

- 设置线程是否**继承**创建者的**调度属性**

```c++
int pthread_attr_setinheritsched(pthread_attr_t *attr, //线程属性参数(出参)
                                 int inheritsched);    //是否继承父线程的调度策略
```

​	第二个参数的可选参数如下：

PTHREAD_INHERIT_SCHED：继承父进程的调度策略；

PTHREAD_EXPLICIT_SCHED：不继承父进程的调度策略。**只有不继承父进程的调度策略，才能定制线程的调度策略**。

- 设置线程调度策略

```c++
int pthread_attr_setschedpolicy(pthread_attr_t *attr,//线程属性参数(出参) 
                                int policy);         //调度策略
```

​	在不继承父进程的调度策略的情况下，才能设置待创建线程的调度策略，第二个参数如下：

① **SCHED_FIFO**：抢占式调度，优先级高的线程先运行，优先级相等的按先进先出的顺序进行调度。

② **SCHED_RR**：轮询式调度，每个线程分配一个时间片，时间片到了就切换到下一个线程，直到所有线程都运行完一次为止。

③ **SCHED_OTHER**：默认调度策略。

- 设置线程调度参数(**优先级**)

```c++
int pthread_attr_setschedparam(pthread_attr_t *attr,            //线程属性参数(出参) 
                               const struct sched_param *param);//调度参数
```

​	调度参数设置的是线程的**静态优先级**。数值越大，优先级越高。

- 创建线程

```c++
pthread_create(pthread_t *thread,              //标识构建的线程(出参)
               const pthread_attr_t *attr,     //线程属性参数
               void *(*start_routine) (void *),//线程执行函数 
               void *arg)                      //线程函数参数
```

​	示例：

```c++
// 线程的优先级可以通过设置线程属性来实现。
// thread init
pthread_t audio_tid;
pthread_attr_t thread_pro;//线程属性，默认为NULL
pthread_attr_init(&thread_pro);//属性变量初始化
pthread_attr_setinheritsched(&thread_pro, PTHREAD_EXPLICIT_SCHED);//不继承父线程的调度属性
pthread_attr_setschedpolicy(&thread_pro, SCHED_RR);//设置调度策略为轮询式调度
struct sched_param s_param;//设置参数
s_param.sched_priority = sched_get_priority_max(SCHED_RR);//获取轮询式调度的最大优先级
pthread_attr_setschedparam(&thread_pro, &s_param);//设置线程schedparam属性，即调用的优先级
ret = pthread_create(&audio_tid, &thread_pro, AudioThread, this);// 创建线程
```

## 2 Linux内核的线程调度策略

① SCHED_OTHER：**分时调度**，**默认**调度策略，是相对较低优先级。

​	依靠时间片轮转的方式来进行调度，不会干扰SCHED_FIFO和SCHED_RR线程的执行。

​	当所有SCHED_FIFO和SCHED_RR线程都没有需要执行时，才会轮到SCHED_OTHER线程执行。

② SCHED_FIFO：**抢占式调度**(实时调度策略)。**一旦占用cpu则一直运行，直到有更高优先级任务到达或自己放弃**。

③ SCHED_RR：**轮询式调度**(实时调度策略)。根据优先级，为每个线程计算时间片并分配。当线程的时间片用完，系统将重新分配，并置于**就绪队列队尾**。放在队尾保证了所有具有相同优先级的RR任务的调度公平。

## 3 C++ 11的std::thread

### 1) std::thread和Linux中pthread区别

① std::thread是C++11标准库中的线程API，而pthread是POSIX标准的线程API，两者的调用方式和语法有所不同。

② std::thread是C++11面向对象的API，它以类和对象的形式封装了线程的相关操作，使得线程的管理更加简单方便；

​	pthread是面向过程的API，它需要手动创建和操作线程对象，比较繁琐。

③ std::thread的跨平台性更强，可以在所有支持C++11的平台上运行；

​	pthread只能在支持POSIX标准的平台上运行。

④ std::thread提供了一些C++11独有的特性，比如可以采用Lambda表达式来定义线程函数，避免了定义全局函数的麻烦，还提供了方便的线程同步机制，如std::mutex、std::condition_variable等。

​	综上，std::thread比pthread更加面向对象、跨平台、方便和安全，但是如果需要兼容旧的POSIX代码或使用特定的线程特性，pthread仍然是一个不错的选择。

### 2) std::thread设置线程优先级

​	C++标准库没有提供设置线程优先级的API，因此不能直接使用成员函数/库函数。

​	若要通过std::thread设置线程优先级、调度策略等，需要获取**线程原生句柄**，并**结合平台的API**，如下所示：

```c++
#include <iostream>
#include <thread>
#include <pthread.h>
#include <sched.h>

void thread_func()
{
    // 线程执行的任务
}

int main()
{
    std::thread t(thread_func);
    // 修改线程的调度策略和优先级
    int policy = SCHED_RR; // 设置为轮流调度
    int priority = 10; // 设置优先级为 10
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setschedpolicy(&attr, policy);
    sched_param param;
    param.sched_priority = priority;
    pthread_attr_setschedparam(&attr, &param);
    pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
    
    pthread_t thread_handle = t.native_handle();         //获取线程原生句柄
    pthread_setschedparam(thread_handle, policy, &param);//设置线程属性
    t.join();
    return 0;
}
```

# 进程的地址空间

​	本小节参考自：[C++进程间通信之共享内存](https://blog.csdn.net/cylddrmm123/article/details/134096333)、 [Linux虚拟内存详解](https://blog.csdn.net/qq_38410730/article/details/81036768)。

​	每个运行中的进程都有自己的地址空间，用于存储其代码、数据和栈等信息。

​	进程的地址空间是：① **独立**使用的**虚拟地址空间**；② 这块空间是连续的内存区域。

## 1 虚拟内存

​	**为了运行比实际物理内存容量还要大的程序**，所有现代操作系统几乎都采用了虚拟内存技术。虚拟内存让系统**看上去**具有比实际物理内存更大的空间，为实现多道程序执行创造了条件。

​	虚拟内存是对**物理内存的抽象**，系统为每个进程提供了一个独立且私有的地址空间(从0开始)。

​	这样，不同进程虽然虚拟空间地址的值可能相等，但实际是**相互隔离的**，每个进程都认为自己独占了整个物理地址空间。

### 1) 处理器的寻址能力

​	对于程序计数器位数为32位的处理器来说，其地址发生器所能发出的地址数目为2^32=4G个。

​	于是这个处理器所能访问的最大内存空间就是4G。这个值就叫做处理器的**寻址空间**或**寻址能力**。

​	下述情况，处理器寻址能力会被浪费：

​	① 若具有32位寻址能力的处理器只配置了256M的内存储器，这就会造成大量的浪费，如下：

<img src=".\pic\pc_adress.png" alt="pc_adress" style="zoom:80%;" />

​	② 一些处理器因**外部地址线的根数小于处理器程序计数器的位数**，使地址总线的根数不满足处理器的寻址范围，让处理器的寻址能力被浪费。

​	例如：Intel8086处理器的程序计数器为32位，而处理器芯片的外部地址总线只有20根，所以它所能配置的最大内存为1MB。

### 2) 程序总是逐段运行

​	**一个应用程序总是逐段被运行，而且在一段时间内会稳定运行在某一段程序里**。

​	把要运行的那一段程序从磁盘中拷贝到内存中来运行，而其他暂时不运行的程序段就让它仍然留在磁盘中。

​	当需要执行另一端尚未在内存的程序段，如下图所示，可把内存中程序段1的副本**换出**，腾出必要的空间后，再把磁盘中程序段2**换回**到内存空间来执行即可：

<img src=".\pic\pc_virtual_mem_in_out.png" alt="pc_virtual_mem_in_out" style="zoom:90%;" />

​	**经过不断有目的的换入和换出，处理器就可以运行一个大于实际物理内存的应用程序了**。

​	或者说，处理器拥有了一个大于实际物理内存的内存空间，这就是虚拟内存空间。**计算机虚拟内存空间的大小是由程序计数器的寻址能力来决定的。**例如：在程序计数器的位数为32的处理器中，它的虚拟内存空间就为4GB。

### 3) mmu和内存映射

​	由于存在两个内存地址，因此一个应用程序从编写到被执行，需要进行两次映射：**第一次是映射到虚拟内存空间，第二次是映射到物理内存空间**。

​	这两次映射是由**硬件**和**软件**共同完成，承担这个任务的硬件部分叫做**存储管理单元MMU**，软件部分就是操作系统的**内存管理模块**。

​	在**映射**工作中，操作系统的内存管理模块需要建立一个**表格**，该表格以虚拟地址为索引，记录了程序段所占用的物理内存的物理地址。

<img src=".\pic\pc_virtual_mem_map.png" alt="pc_virtual_mem_map" style="zoom:90%;" />

​	从处理器运算装置和程序设计人员的角度来看，它面对的是一个用**MMU**、**映射记录表**和**虚拟内存空间**，存储空间的大小取决于处理器**程序计数器**的寻址空间。

​	在一个具体时刻，处理器只能使用一个程序的映射记录表，因此它只看到多个程序虚存空间中的一个，这样就保证了各个程序的虚拟内存空间**互不相扰**、**各自独立**。

### 4) 虚拟内存的页、物理内存的页框及页表

​	Linux把虚存空间分成**若干个大小相等**的存储分区，Linux把这样的分区叫做**页**。为了换入、换出的方便，物理内存也得划分成**若干大小相等的块**，叫做**页框**。页与页框是实现虚拟内存技术的基础。

​	**在Linux中，页与页框的大小一般为4KB**。根据系统和应用的不同，页与页框的大小也可有所变化。

#### 4.1) 页码/页框码和偏移量

​	页和页框的地址被分为了两段：高位为页码/页框码，低位为页内/页框偏移量：

<img src=".\pic\pc_page_offset.png" alt="pc_page_offset" style="zoom:80%;" />

​	为了正确的将虚拟内存的页码和物理内存的页框码映射，就必须把页码和对应的页框码填入一个叫做**页表**的表项中。这个页表就是**映射记录表**，如下所示：

<img src=".\pic\pc_page_table.png" alt="pc_page_table" style="zoom:80%;" />

​	综上：CPU遇到的地址**都是虚拟地址**。虚拟地址和物理地址都分成**页码(页框码)和偏移值两部分**。在由虚拟地址转化成物理地址的过程中，**偏移值不变**。而页码和页框码之间的映射就在一个映射记录表——**页表中**。

#### 4.2) 请页

​	请页：将虚拟内存页的地址映射到空闲的物理页框中，并在**页表**上完成记录。

##### 4.2.1) 请页触发时机

① CPU访问虚拟地址时，会根据地址找到页码，再去页表中查询该页码对应的物理页框码；

② 如果虚拟页码对应的**页框码存在**，MMU会把页码转换成页框码，并加上偏移量，访问对应的物理内存。

③ 如果虚拟页码对应的**页框码不存在**，则意味着对应的页框还未被载入内存，此时MMU会通知操作系统，发生了**缺页异常**，操作系统会**调起请页机制**。

##### 4.2.2) 请页流程和页交换

① 若虚拟地址是有效地址，从物理内存中找到一块**空闲的页框**，将该页和页框映射，并记录在**页表**上。之后CPU从发生缺页异常的地方**重新运行**。

② 若虚拟地址是无效地址，系统将终止访问。

③ 若在①的过程中，发现**没有空闲的物理页框**，系统必须启动**交换**机制：调用内核操作函数，在物理页框中寻找一个当前不再使用或者近期可能不会用到的页面所占据的页框。找到后，就把其中的页移出，以装载新的页面。

​	对移出页面根据两种情况来处理：如果该页未被修改过，则删除它；如果该页曾经被修改过，则系统必须将该页写回磁盘。

​	为了公平地选择将要从系统中抛弃的页面，**Linux系统使用最近最少使用(LRU)页面的衰老算法**。

<img src=".\pic\pc_page_error.png" alt="pc_page_error" style="zoom:80%;" />







